<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MOV → Animated WebP (≤ 250 KB)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    button { padding: 10px 14px; cursor: pointer; }
    button[disabled] { opacity: .55; cursor: not-allowed; }
    #log { white-space: pre-wrap; background: #0b0b0b; color: #e9e9e9; padding: 10px; border-radius: 8px; max-height: 220px; overflow: auto; }
    video, img { max-width: 100%; border-radius: 10px; background: #111; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin-top: 12px; }
    .muted { color: #666; }
    progress { width: 100%; height: 14px; }
    a { display: inline-block; margin-top: 10px; }
    code { background: #f3f3f3; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <h2>MOV → Hareketli WebP (≤ 250 KB)</h2>

  <div class="card">
    <div class="row">
      <input id="file" type="file" accept="video/quicktime,video/*,.mov" />
      <button id="convert" disabled>Convert (≤ 250 KB)</button>
      <span id="status" class="muted"></span>
    </div>
    <div style="margin-top:10px">
      <progress id="prog" value="0" max="1"></progress>
      <div class="muted" style="margin-top:6px">
        Not: Bu sayfayı <code>http(s)://</code> üzerinden açın. <code>file://</code> ile bazı tarayıcılarda çalışmayabilir.
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Giriş Önizleme</h3>
    <video id="inVid" controls muted playsinline></video>
    <div class="muted" id="meta"></div>
  </div>

  <div class="card">
    <h3>Çıktı Önizleme (Animated WebP)</h3>
    <img id="outImg" alt="output" />
    <div class="row">
      <a id="dl" download="output.webp" style="display:none">İndir: output.webp</a>
      <span id="outInfo" class="muted"></span>
    </div>
  </div>

  <div class="card">
    <h3>Log</h3>
    <div id="log"></div>
  </div>

  <!-- ffmpeg.wasm (UMD) -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js"></script>

  <script>
    (() => {
      const TARGET_BYTES = 250 * 1024;

      const elFile = document.getElementById('file');
      const elConvert = document.getElementById('convert');
      const elStatus = document.getElementById('status');
      const elProg = document.getElementById('prog');
      const elLog = document.getElementById('log');
      const elInVid = document.getElementById('inVid');
      const elMeta = document.getElementById('meta');
      const elOutImg = document.getElementById('outImg');
      const elDl = document.getElementById('dl');
      const elOutInfo = document.getElementById('outInfo');

      let inputFile = null;
      let inputURL = null;
      let outURL = null;

      let ffmpeg = null;
      let ffmpegLoadPromise = null;

      const logLine = (s) => {
        elLog.textContent = (elLog.textContent ? elLog.textContent + "\n" : "") + s;
        elLog.scrollTop = elLog.scrollHeight;
      };

      const setStatus = (s) => { elStatus.textContent = s || ""; };

      const revokeIf = (url) => {
        try { if (url) URL.revokeObjectURL(url); } catch (_) {}
      };

      const bytesToKB = (b) => (b / 1024).toFixed(1);

      const toBlobURL = async (url, mimeType) => {
        const res = await fetch(url, { cache: "force-cache" });
        if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText} (${url})`);
        const buf = await res.arrayBuffer();
        const blob = new Blob([buf], { type: mimeType });
        return URL.createObjectURL(blob);
      };

      const safeExt = (name) => {
        const m = (name || "").match(/(\.[a-z0-9]+)$/i);
        return m ? m[1].toLowerCase() : ".mov";
      };

      const waitVideoMeta = (videoEl) =>
        new Promise((resolve, reject) => {
          const onOk = () => { cleanup(); resolve(); };
          const onErr = () => { cleanup(); reject(new Error("Video metadata okunamadı.")); };
          const cleanup = () => {
            videoEl.removeEventListener('loadedmetadata', onOk);
            videoEl.removeEventListener('error', onErr);
          };
          videoEl.addEventListener('loadedmetadata', onOk, { once: true });
          videoEl.addEventListener('error', onErr, { once: true });
        });

      const loadFFmpegIfNeeded = async () => {
        if (ffmpeg && ffmpeg.loaded) return;

        if (ffmpegLoadPromise) return ffmpegLoadPromise;

        if (!window.FFmpegWASM || !window.FFmpegWASM.FFmpeg) {
          throw new Error("FFmpegWASM yüklenemedi (CDN engellenmiş olabilir).");
        }

        ffmpeg = new window.FFmpegWASM.FFmpeg();

        ffmpeg.on('log', ({ message }) => {
          // Çok spam olmasın diye bazı logları kırpıyoruz:
          if (message && typeof message === "string") logLine(message);
        });

        ffmpeg.on('progress', (p) => {
          // p: { progress, time } (0..1)
          if (p && typeof p.progress === "number") {
            elProg.value = Math.max(0, Math.min(1, p.progress));
          }
        });

        const canMT = !!(window.crossOriginIsolated && typeof SharedArrayBuffer !== "undefined");

        const baseCore = canMT
          ? "https://unpkg.com/@ffmpeg/core-mt@0.12.10/dist/umd"
          : "https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd";

        setStatus(`FFmpeg-core yükleniyor... (${canMT ? "multi-thread" : "single-thread"})`);
        logLine(`Core: ${baseCore}`);

        ffmpegLoadPromise = (async () => {
          const coreURL = await toBlobURL(`${baseCore}/ffmpeg-core.js`, "text/javascript");
          const wasmURL = await toBlobURL(`${baseCore}/ffmpeg-core.wasm`, "application/wasm");

          const cfg = { coreURL, wasmURL };
          if (canMT) {
            cfg.workerURL = await toBlobURL(`${baseCore}/ffmpeg-core.worker.js`, "text/javascript");
          }

          await ffmpeg.load(cfg);
          setStatus("FFmpeg hazır.");
        })();

        return ffmpegLoadPromise;
      };

      const cleanFS = async (paths) => {
        for (const p of paths) {
          try { await ffmpeg.deleteFile(p); } catch (_) {}
        }
      };

      const encodeOnce = async ({ inputName, outName, fps, q, w, h }) => {
        const vf = (w && h)
          ? `fps=${fps},scale=${w}:${h}:flags=lanczos`
          : `fps=${fps}`;

        // -q:v 0..100 (yüksek = daha iyi kalite)
        const args = [
          "-y",
          "-i", inputName,
          "-an",
          "-vsync", "0",
          "-vf", vf,
          "-c:v", "libwebp",
          "-loop", "0",
          "-lossless", "0",
          "-pix_fmt", "yuv420p",
          "-compression_level", "6",
          "-q:v", String(q),
          "-map_metadata", "-1",
          outName
        ];

        await cleanFS([outName]);
        elProg.value = 0;
        await ffmpeg.exec(args);

        const data = await ffmpeg.readFile(outName); // Uint8Array
        return data;
      };

      const convertWithTarget = async ({ file, w, h }) => {
        const ext = safeExt(file.name);
        const inputName = `input${ext}`;
        const outName = "output.webp";

        await cleanFS([inputName, outName]);

        setStatus("Dosya hazırlanıyor...");
        elProg.value = 0;

        const buf = await file.arrayBuffer();
        await ffmpeg.writeFile(inputName, new Uint8Array(buf));

        // Ayar araması (çözünürlük sabit, sadece fps/kalite düşürerek küçültür)
        // Not: 9-10sn yüksek çözünürlükte 250KB her zaman mümkün olmayabilir.
        let fps = 12;
        let q = 75;

        // Giriş FPS’i çok yüksekse zaten düşürmek boyuta ciddi etki eder.
        // Çok büyük dosyalarda daha agresif başlamak için:
        if (w && h && (w * h >= 1280 * 720)) fps = 8;

        let best = null;

        const maxAttempts = 12;
        for (let i = 0; i < maxAttempts; i++) {
          setStatus(`Dönüştürülüyor... (Deneme ${i + 1}/${maxAttempts}) fps=${fps}, kalite=${q}`);
          logLine(`\n--- Deneme ${i + 1}: fps=${fps}, q=${q} ---`);

          const data = await encodeOnce({ inputName, outName, fps, q, w, h });
          const size = data.length;

          logLine(`Çıktı boyutu: ${size} bytes (${bytesToKB(size)} KB)`);

          if (size <= TARGET_BYTES) {
            best = data;
            break;
          }

          // Ayar güncelle (heuristic)
          const ratio = TARGET_BYTES / size; // < 1 ise küçültmek lazım
          if (q > 20) {
            const prevQ = q;
            q = Math.max(20, Math.min(prevQ - 5, Math.floor(prevQ * ratio * 0.92)));
            if (q >= prevQ) q = prevQ - 10;
            q = Math.max(20, q);
          } else if (fps > 4) {
            fps = Math.max(4, Math.floor(fps * 0.8));
            q = 75; // fps düşürünce kaliteyi tekrar yükseltip yeniden dene
          } else {
            // Daha fazla düşürmeden (çözünürlük sabit) sığmıyor
            best = data; // en son denemeyi döndür
            break;
          }
        }

        await cleanFS([inputName]); // giriş dosyasını temizle

        return { data: best, outName };
      };

      const setOutput = (uint8) => {
        revokeIf(outURL);
        outURL = URL.createObjectURL(new Blob([uint8.buffer], { type: "image/webp" }));
        elOutImg.src = outURL;

        elDl.href = outURL;
        elDl.style.display = "inline-block";

        elOutInfo.textContent = `Boyut: ${bytesToKB(uint8.length)} KB (hedef: ${(TARGET_BYTES/1024).toFixed(0)} KB)`;
      };

      elFile.addEventListener('change', async () => {
        inputFile = elFile.files && elFile.files[0] ? elFile.files[0] : null;
        revokeIf(inputURL);
        revokeIf(outURL);
        elDl.style.display = "none";
        elOutInfo.textContent = "";
        elOutImg.removeAttribute("src");
        elLog.textContent = "";
        elProg.value = 0;

        if (!inputFile) {
          elConvert.disabled = true;
          elInVid.removeAttribute("src");
          elMeta.textContent = "";
          setStatus("");
          return;
        }

        inputURL = URL.createObjectURL(inputFile);
        elInVid.src = inputURL;

        try {
          setStatus("Video metadatası okunuyor...");
          await waitVideoMeta(elInVid);
          const w = elInVid.videoWidth || 0;
          const h = elInVid.videoHeight || 0;
          const d = isFinite(elInVid.duration) ? elInVid.duration : 0;
          elMeta.textContent = `Giriş: ${w}×${h} | Süre: ${d ? d.toFixed(2) + " sn" : "?"} | Dosya: ${bytesToKB(inputFile.size)} KB`;
          setStatus("Hazır.");
          elConvert.disabled = false;
        } catch (e) {
          elMeta.textContent = "";
          setStatus("Video okunamadı.");
          elConvert.disabled = true;
          logLine(String(e && e.message ? e.message : e));
        }
      });

      elConvert.addEventListener('click', async () => {
        if (!inputFile) return;

        try {
          elConvert.disabled = true;
          elDl.style.display = "none";
          elOutInfo.textContent = "";
          elOutImg.removeAttribute("src");
          elProg.value = 0;

          if (location.protocol === "file:") {
            logLine("Uyarı: file:// ile bazı tarayıcılarda Worker/wasm kısıtları nedeniyle çalışmayabilir. HTTP üzerinden açın.");
          }

          await loadFFmpegIfNeeded();

          const w = elInVid.videoWidth || 0;
          const h = elInVid.videoHeight || 0;

          const { data } = await convertWithTarget({ file: inputFile, w, h });

          if (!data || !data.length) throw new Error("Çıktı üretilemedi.");

          setOutput(data);

          if (data.length <= TARGET_BYTES) {
            setStatus("Bitti. (≤ 250 KB)");
          } else {
            setStatus("Bitti ama 250 KB altına inemedi (çözünürlük sabit).");
            logLine("Not: Çözünürlük sabitken 9-10 sn videoda 250 KB her zaman mümkün olmayabilir. Daha fazla küçültme için çözünürlük düşürmek gerekir.");
          }
        } catch (e) {
          setStatus("Hata.");
          logLine("\nHATA: " + String(e && e.message ? e.message : e));
        } finally {
          elConvert.disabled = !inputFile;
        }
      });
    })();
  </script>
</body>
</html>
