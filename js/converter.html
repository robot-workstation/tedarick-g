<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MOV → Animated WebP (≤ 250 KB)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    button { padding:10px 14px; cursor:pointer; }
    button[disabled] { opacity:.55; cursor:not-allowed; }
    #log { white-space:pre-wrap; background:#0b0b0b; color:#e9e9e9; padding:10px; border-radius:8px; max-height:240px; overflow:auto; }
    video, img { max-width:100%; border-radius:10px; background:#111; }
    .card { border:1px solid #ddd; border-radius:12px; padding:12px; margin-top:12px; }
    .muted { color:#666; }
    progress { width:100%; height:14px; }
    code { background:#f3f3f3; padding:2px 6px; border-radius:6px; }
    a { display:inline-block; margin-top:10px; }
  </style>
</head>
<body>
  <h2>MOV → Hareketli WebP (≤ 250 KB)</h2>

  <div class="card">
    <div class="row">
      <input id="file" type="file" accept="video/quicktime,video/*,.mov" />
      <button id="convert" disabled>Convert (≤ 250 KB)</button>
      <span id="status" class="muted"></span>
    </div>
    <div style="margin-top:10px">
      <progress id="prog" value="0" max="1"></progress>
      <div class="muted" style="margin-top:6px">
        Not: Bu sayfa <code>http(s)://</code> üzerinden açılmalı. <code>file://</code> bazı tarayıcılarda çalışmayabilir.
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Giriş Önizleme</h3>
    <video id="inVid" controls muted playsinline></video>
    <div class="muted" id="meta"></div>
  </div>

  <div class="card">
    <h3>Çıktı Önizleme (Animated WebP)</h3>
    <img id="outImg" alt="output" />
    <div class="row">
      <a id="dl" download="output.webp" style="display:none">İndir: output.webp</a>
      <span id="outInfo" class="muted"></span>
    </div>
  </div>

  <div class="card">
    <h3>Log</h3>
    <div id="log"></div>
  </div>

  <script type="module">
    const TARGET_BYTES = 250 * 1024;

    const elFile = document.getElementById('file');
    const elConvert = document.getElementById('convert');
    const elStatus = document.getElementById('status');
    const elProg = document.getElementById('prog');
    const elLog = document.getElementById('log');
    const elInVid = document.getElementById('inVid');
    const elMeta = document.getElementById('meta');
    const elOutImg = document.getElementById('outImg');
    const elDl = document.getElementById('dl');
    const elOutInfo = document.getElementById('outInfo');

    let inputFile = null;
    let inputURL = null;
    let outURL = null;

    let ffmpeg = null;
    let ffmpegLoaded = false;
    let loadingPromise = null;

    const logLine = (s) => {
      elLog.textContent = (elLog.textContent ? elLog.textContent + "\n" : "") + s;
      elLog.scrollTop = elLog.scrollHeight;
    };
    const setStatus = (s) => elStatus.textContent = s || "";
    const bytesToKB = (b) => (b / 1024).toFixed(1);
    const revokeIf = (url) => { try { if (url) URL.revokeObjectURL(url); } catch {} };

    const waitVideoMeta = (videoEl) =>
      new Promise((resolve, reject) => {
        const ok = () => { cleanup(); resolve(); };
        const err = () => { cleanup(); reject(new Error("Video metadata okunamadı.")); };
        const cleanup = () => {
          videoEl.removeEventListener('loadedmetadata', ok);
          videoEl.removeEventListener('error', err);
        };
        videoEl.addEventListener('loadedmetadata', ok, { once: true });
        videoEl.addEventListener('error', err, { once: true });
      });

    const toBlobURL = async (url, mimeType) => {
      const res = await fetch(url, { cache: "force-cache" });
      if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText} (${url})`);
      const buf = await res.arrayBuffer();
      const blob = new Blob([buf], { type: mimeType });
      return URL.createObjectURL(blob);
    };

    // ffmpeg.js içindeki cross-origin worker çağrısını blob URL ile değiştirmek için patch
    const toBlobURLPatched = async (url, mimeType, patcher) => {
      const res = await fetch(url, { cache: "force-cache" });
      if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText} (${url})`);
      let txt = await res.text();
      if (patcher) txt = patcher(txt);
      const blob = new Blob([txt], { type: mimeType });
      return URL.createObjectURL(blob);
    };

    const cleanFS = async (paths) => {
      for (const p of paths) {
        try { await ffmpeg.deleteFile(p); } catch {}
      }
    };

    async function loadFFmpegIfNeeded() {
      if (ffmpegLoaded) return;
      if (loadingPromise) return loadingPromise;

      loadingPromise = (async () => {
        setStatus("FFmpeg hazırlanıyor...");

        // CDN URL'leri (RAW unpkg)
        const baseFFMPEG = "https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd";
        const baseCore  = "https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd";

        // 1) 814.ffmpeg.js cross-origin Worker hatasını çözmek için ffmpeg.js'i patch ederek blob'a al
        const ffmpegBlobURL = await toBlobURLPatched(
          `${baseFFMPEG}/ffmpeg.js`,
          "text/javascript",
          (js) => js.replace("new URL(e.p+e.u(814),e.b)", "r.worker814URL")
        );

        // 2) worker (814) + core js + wasm dosyalarını blob URL yap (same-origin gibi davranır)
        const worker814URL = await toBlobURL(`${baseFFMPEG}/814.ffmpeg.js`, "text/javascript");
        const coreURL = await toBlobURL(`${baseCore}/ffmpeg-core.js`, "text/javascript");
        const wasmURL = await toBlobURL(`${baseCore}/ffmpeg-core.wasm`, "application/wasm");

        // 3) ffmpeg.js'i yükle (globalThis.FFmpegWASM oluşur)
        await import(ffmpegBlobURL);

        if (!globalThis.FFmpegWASM?.FFmpeg) {
          throw new Error("FFmpegWASM yüklenemedi.");
        }

        ffmpeg = new globalThis.FFmpegWASM.FFmpeg();

        ffmpeg.on("log", ({ message }) => {
          if (message && typeof message === "string") logLine(message);
        });
        ffmpeg.on("progress", (p) => {
          if (p && typeof p.progress === "number") {
            elProg.value = Math.max(0, Math.min(1, p.progress));
          }
        });

        // 4) load (patched ffmpeg.js artık worker814URL blob'unu kullanacak)
        await ffmpeg.load({
          worker814URL,
          coreURL,
          wasmURL
        });

        ffmpegLoaded = true;
        setStatus("FFmpeg hazır.");
      })();

      return loadingPromise;
    }

    const safeExt = (name) => {
      const m = (name || "").match(/(\.[a-z0-9]+)$/i);
      return m ? m[1].toLowerCase() : ".mov";
    };

    async function encodeOnce({ inputName, outName, fps, q, w, h }) {
      const vf = (w && h)
        ? `fps=${fps},scale=${w}:${h}:flags=lanczos`
        : `fps=${fps}`;

      const args = [
        "-y",
        "-i", inputName,
        "-an",
        "-vsync", "0",
        "-vf", vf,
        "-c:v", "libwebp",
        "-loop", "0",
        "-lossless", "0",
        "-pix_fmt", "yuv420p",
        "-compression_level", "6",
        "-q:v", String(q),
        "-map_metadata", "-1",
        outName
      ];

      await cleanFS([outName]);
      elProg.value = 0;
      await ffmpeg.exec(args);

      const data = await ffmpeg.readFile(outName);
      return data;
    }

    async function convertWithTarget({ file, w, h }) {
      const ext = safeExt(file.name);
      const inputName = `input${ext}`;
      const outName = "output.webp";

      await cleanFS([inputName, outName]);

      setStatus("Dosya hazırlanıyor...");
      elProg.value = 0;

      const buf = await file.arrayBuffer();
      await ffmpeg.writeFile(inputName, new Uint8Array(buf));

      let fps = 12;
      let q = 75;
      if (w && h && (w * h >= 1280 * 720)) fps = 8;

      let best = null;

      const maxAttempts = 12;
      for (let i = 0; i < maxAttempts; i++) {
        setStatus(`Dönüştürülüyor... (Deneme ${i + 1}/${maxAttempts}) fps=${fps}, kalite=${q}`);
        logLine(`\n--- Deneme ${i + 1}: fps=${fps}, q=${q} ---`);

        const data = await encodeOnce({ inputName, outName, fps, q, w, h });
        const size = data.length;

        logLine(`Çıktı boyutu: ${size} bytes (${bytesToKB(size)} KB)`);

        if (size <= TARGET_BYTES) {
          best = data;
          break;
        }

        const ratio = TARGET_BYTES / size; // < 1 küçült
        if (q > 20) {
          const prevQ = q;
          q = Math.max(20, Math.min(prevQ - 5, Math.floor(prevQ * ratio * 0.92)));
          if (q >= prevQ) q = prevQ - 10;
          q = Math.max(20, q);
        } else if (fps > 4) {
          fps = Math.max(4, Math.floor(fps * 0.8));
          q = 75;
        } else {
          best = data; // daha fazla düşmeden sığmıyor (çözünürlük sabit)
          break;
        }
      }

      await cleanFS([inputName]);
      return best;
    }

    function setOutput(uint8) {
      revokeIf(outURL);
      outURL = URL.createObjectURL(new Blob([uint8.buffer], { type: "image/webp" }));
      elOutImg.src = outURL;

      elDl.href = outURL;
      elDl.style.display = "inline-block";
      elOutInfo.textContent = `Boyut: ${bytesToKB(uint8.length)} KB (hedef: ${(TARGET_BYTES/1024).toFixed(0)} KB)`;
    }

    elFile.addEventListener("change", async () => {
      inputFile = elFile.files && elFile.files[0] ? elFile.files[0] : null;

      revokeIf(inputURL);
      revokeIf(outURL);

      elDl.style.display = "none";
      elOutInfo.textContent = "";
      elOutImg.removeAttribute("src");
      elLog.textContent = "";
      elProg.value = 0;

      if (!inputFile) {
        elConvert.disabled = true;
        elInVid.removeAttribute("src");
        elMeta.textContent = "";
        setStatus("");
        return;
      }

      inputURL = URL.createObjectURL(inputFile);
      elInVid.src = inputURL;

      try {
        setStatus("Video metadatası okunuyor...");
        await waitVideoMeta(elInVid);
        const w = elInVid.videoWidth || 0;
        const h = elInVid.videoHeight || 0;
        const d = isFinite(elInVid.duration) ? elInVid.duration : 0;

        elMeta.textContent = `Giriş: ${w}×${h} | Süre: ${d ? d.toFixed(2) + " sn" : "?"} | Dosya: ${bytesToKB(inputFile.size)} KB`;
        setStatus("Hazır.");
        elConvert.disabled = false;
      } catch (e) {
        elMeta.textContent = "";
        setStatus("Video okunamadı.");
        elConvert.disabled = true;
        logLine(String(e?.message || e));
      }
    });

    elConvert.addEventListener("click", async () => {
      if (!inputFile) return;

      try {
        elConvert.disabled = true;
        elDl.style.display = "none";
        elOutInfo.textContent = "";
        elOutImg.removeAttribute("src");
        elProg.value = 0;

        if (location.protocol === "file:") {
          logLine("Uyarı: file:// ile çalışmayabilir. HTTP/HTTPS üzerinden açın.");
        }

        await loadFFmpegIfNeeded();

        const w = elInVid.videoWidth || 0;
        const h = elInVid.videoHeight || 0;

        const data = await convertWithTarget({ file: inputFile, w, h });
        if (!data || !data.length) throw new Error("Çıktı üretilemedi.");

        setOutput(data);

        if (data.length <= TARGET_BYTES) {
          setStatus("Bitti. (≤ 250 KB)");
        } else {
          setStatus("Bitti ama 250 KB altına inemedi (çözünürlük sabit).");
          logLine("Not: Çözünürlük sabitken 9-10 sn videoda 250 KB her zaman mümkün olmayabilir.");
        }
      } catch (e) {
        setStatus("Hata.");
        logLine("\nHATA: " + String(e?.message || e));
      } finally {
        elConvert.disabled = !inputFile;
      }
    });
  </script>
</body>
</html>
